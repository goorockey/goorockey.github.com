<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Goorockey&#39;s Blog</title>
  <subtitle>create something special</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.goorockey.com/"/>
  <updated>2021-08-09T15:53:17.697Z</updated>
  <id>http://www.goorockey.com/</id>
  
  <author>
    <name>goorockey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>回收Virtualbox硬盘空间</title>
    <link href="http://www.goorockey.com/2017/02/02/shrink-virtualbox-disk/"/>
    <id>http://www.goorockey.com/2017/02/02/shrink-virtualbox-disk/</id>
    <published>2017-02-02T07:07:54.000Z</published>
    <updated>2021-08-09T15:53:17.697Z</updated>
    
    <content type="html"><![CDATA[<p>Virtualbox虚拟机的虚拟硬盘文件（一般是vdi文件），支持根据使用情况动态增加，即创建硬盘时候设置大小为128G，并不会直接在宿主机创建一个128G的文件，而是根据虚拟机的使用慢慢增加。</p>
<p>但虚拟硬盘文件的大小不会因为虚拟机里面使用空间减少就自动缩减，需要使用工具完成。</p>
<a id="more"></a>
<p>对于Linux虚拟机，Ubuntu为例：</p>
<ul>
<li><p>安装zerofree</p>
<pre><code>$ apt-get install zerofree
</code></pre></li>
<li><p>重启虚拟机</p>
</li>
<li>在启动的grub菜单，选择进入recovery模式</li>
<li><p>对要回收的硬盘，以只读模式重新挂载</p>
<pre><code>$ mount -n -o remount,ro -t ext4 /dev/sda1 /
</code></pre></li>
<li><p>使用zerofree把硬盘没使用的空间置零</p>
<pre><code>$ zerofree /dev/sda1
</code></pre></li>
<li><p>关闭虚拟机</p>
</li>
<li><p>在宿主机使用VBoxManage工具压缩vdi文件，回收空间</p>
<pre><code>VBoxManage.exe modifyhd xxx.vdi compact
</code></pre></li>
</ul>
<p>Done!</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Virtualbox虚拟机的虚拟硬盘文件（一般是vdi文件），支持根据使用情况动态增加，即创建硬盘时候设置大小为128G，并不会直接在宿主机创建一个128G的文件，而是根据虚拟机的使用慢慢增加。&lt;/p&gt;
&lt;p&gt;但虚拟硬盘文件的大小不会因为虚拟机里面使用空间减少就自动缩减，需要使用工具完成。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.goorockey.com/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.goorockey.com/tags/linux/"/>
    
      <category term="Virtualbox" scheme="http://www.goorockey.com/tags/Virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>Angular2初试小记</title>
    <link href="http://www.goorockey.com/2016/09/13/angular2-note/"/>
    <id>http://www.goorockey.com/2016/09/13/angular2-note/</id>
    <published>2016-09-13T09:21:34.000Z</published>
    <updated>2021-08-09T15:53:17.696Z</updated>
    
    <content type="html"><![CDATA[<p>最近一个网站尝试用<a href="https://angular.io" target="_blank" rel="external">Angular2</a>，小记一下。</p>
<h2 id="Angular-1-vs-2"><a href="#Angular-1-vs-2" class="headerlink" title="Angular 1 vs 2"></a>Angular 1 vs 2</h2><p>Angular2对比1，做了很大的调整，代码更加组件化，结构会更清晰，通过<a href="https://angular.io/docs/ts/latest/quickstart.html" target="_blank" rel="external">官方教程</a>很快能入手。</p>
<p>同时使用Typescript作为开发语言，支持静态类型检查、js新标准等优点，截止现在使用2.0.2版本的ts。</p>
<p>截止现在，angular2最新版本为rc.7，还在快速更新中，我开发的时候就经历了rc.4到rc.5比较大的改动。幸好angular自己和相关工具的github repo都比较活跃，每天都有人发现问题，提交代码，讨论解决方案。</p>
<p>更多介绍参考<a href="https://angular.io/features.html" target="_blank" rel="external">官方</a>，<a href="https://github.com/angular/angular" target="_blank" rel="external">Github</a></p>
<a id="more"></a>
<h2 id="Angular-cli"><a href="#Angular-cli" class="headerlink" title="Angular-cli"></a>Angular-cli</h2><p><a href="https://github.com/angular/angular-cli" target="_blank" rel="external">Angular-cli</a>是官方维护的很强大的工具，生成出来的项目结构很清晰，能帮助我们以最佳实践构建项目。</p>
<p>cli现在慢慢从SytemJS过渡到用webpack做为构建工具，build效率提升不少，配置也简单，所以推荐用webpack分支(npm -g install angular-cli@webpack)或者直接用github的master分支。</p>
<h2 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h2><ul>
<li><p>Nginx部署</p>
<p>  需要把请求都指向<code>index.html</code>，从而使用angular内部的路由。</p>
<pre><code>server {
  listen 80;
  listen [::]:80;

  root /path/to/project;

  index index.html index.htm;

  server_name www.project.com;

  error_page 404 =200 /index.html;

  location / {
    try_files $uri $uri/ =404;
  }
}
</code></pre></li>
<li><p>Pre-bootstrap</p>
<p>  angular2有个比较诟病的地方，是体积略大。即使是新建的项目，编译出来的main.js也有1M多。这使得第一次访问、浏览器没有缓存的时候，首屏时间会比较糟糕。原因还是angular2的库即使压缩后还是太大了。所以建议还是在<code>index.html</code>增加Loading的动画，提高用户体验。</p>
</li>
</ul>
<h2 id="使用感觉"><a href="#使用感觉" class="headerlink" title="使用感觉"></a>使用感觉</h2><p>因为还是rc版，angular2的一些语法、性能都在不断的调整优化。原生Pipe还比较少，很多需要自己写。社区确实很活跃，问题基本都能找到解答。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Angular官网: <a href="https://angular.io" target="_blank" rel="external">https://angular.io</a></li>
<li>Angular Github: <a href="https://github.com/angular/angular" target="_blank" rel="external">https://github.com/angular/angular</a></li>
<li>Angular-cli: <a href="https://github.com/angular/angular-cli" target="_blank" rel="external">https://github.com/angular/angular-cli</a></li>
<li>Angular快速入门: <a href="http://angular-2-training-book.rangle.io" target="_blank" rel="external">http://angular-2-training-book.rangle.io</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一个网站尝试用&lt;a href=&quot;https://angular.io&quot;&gt;Angular2&lt;/a&gt;，小记一下。&lt;/p&gt;
&lt;h2 id=&quot;Angular-1-vs-2&quot;&gt;&lt;a href=&quot;#Angular-1-vs-2&quot; class=&quot;headerlink&quot; title=&quot;Angular 1 vs 2&quot;&gt;&lt;/a&gt;Angular 1 vs 2&lt;/h2&gt;&lt;p&gt;Angular2对比1，做了很大的调整，代码更加组件化，结构会更清晰，通过&lt;a href=&quot;https://angular.io/docs/ts/latest/quickstart.html&quot;&gt;官方教程&lt;/a&gt;很快能入手。&lt;/p&gt;
&lt;p&gt;同时使用Typescript作为开发语言，支持静态类型检查、js新标准等优点，截止现在使用2.0.2版本的ts。&lt;/p&gt;
&lt;p&gt;截止现在，angular2最新版本为rc.7，还在快速更新中，我开发的时候就经历了rc.4到rc.5比较大的改动。幸好angular自己和相关工具的github repo都比较活跃，每天都有人发现问题，提交代码，讨论解决方案。&lt;/p&gt;
&lt;p&gt;更多介绍参考&lt;a href=&quot;https://angular.io/features.html&quot;&gt;官方&lt;/a&gt;，&lt;a href=&quot;https://github.com/angular/angular&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="programming" scheme="http://www.goorockey.com/categories/programming/"/>
    
    
      <category term="angular2" scheme="http://www.goorockey.com/tags/angular2/"/>
    
      <category term="angular-cli" scheme="http://www.goorockey.com/tags/angular-cli/"/>
    
      <category term="typescript" scheme="http://www.goorockey.com/tags/typescript/"/>
    
      <category term="js" scheme="http://www.goorockey.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>红米2刷第三方rom小记</title>
    <link href="http://www.goorockey.com/2016/07/27/flash-rom-in-redmi2/"/>
    <id>http://www.goorockey.com/2016/07/27/flash-rom-in-redmi2/</id>
    <published>2016-07-27T13:39:29.000Z</published>
    <updated>2021-08-09T15:53:17.696Z</updated>
    
    <content type="html"><![CDATA[<p>由于洁癖，相对于MIUI，更喜欢原生的Android系统，更干净更安全。</p>
<p>今天手贱更新opengapps的时候，把手机刷无限重启了，recovery也进不了，只能重新线刷。借此机会记录一下。</p>
<h2 id="rom选择"><a href="#rom选择" class="headerlink" title="rom选择"></a>rom选择</h2><p>到国外最流行的Android发烧友论坛<a href="http://forum.xda-developers.com" target="_blank" rel="external">xdadevelopers</a>找到对应版块，如红米2的 <a href="http://forum.xda-developers.com/redmi-2/development" target="_blank" rel="external">http://forum.xda-developers.com/redmi-2/development</a></p>
<p>浏览一下rom的更新时间、遗留问题、最后几页的讨论，选择自己觉得比较稳妥的rom，毕竟换不同类型的rom是要清SD卡，重新安装配置软件，很麻烦，谁也不想经常这样。</p>
<a id="more"></a>
<h2 id="recovery"><a href="#recovery" class="headerlink" title="recovery"></a>recovery</h2><p>找到适合自己机型的recovery，对于卡刷需要签名的recovery，fastboot刷则不需要。</p>
<p>需要安装非MIUI的系统，需要第三方的recovery，最流行的TWRP或CWM</p>
<p>刷recovery时，如果能进原有的recovery，可以卡刷，即把要刷的recovery包放到手机里，然后进recovery选择包来安装。</p>
<p>还可以在fastboot模式，刷recovery。一般手机进fastboot是同时按<code>音量减键</code>和<code>开机键</code>开机进入。</p>
<p>进入fastboot模式后，手机连PC，用android工具集（即adb所在的）的fastboot执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">fastboot devices  # 查看fastboot模式的设备</div><div class="line">fastboot flash recovery xxx.img  # 刷recovery</div></pre></td></tr></table></figure>
<h2 id="第三方rom"><a href="#第三方rom" class="headerlink" title="第三方rom"></a>第三方rom</h2><p>进recovery，把rom复制进手机并选择安装，然后清cache和dalvik，重启即可。</p>
<p>对于在已有rom基础上，重新刷另外类型的rom，刷rom之前最好还请data、system。重新刷同样的rom（只是版本升级），可以不用。</p>
<h2 id="opengapps"><a href="#opengapps" class="headerlink" title="opengapps"></a>opengapps</h2><p>现在很多rom里面都会去掉google服务，如果需要，则可以在刷完rom后，刷opengapps</p>
<p>到<a href="http://opengapps.org/" target="_blank" rel="external">http://opengapps.org/</a>找到对应机型和rom android版本的opengapps。</p>
<p>一般选择micro足以，包含最基本的服务。谨慎刷nano和pico，刷后不一定能保证机子能正常启动。</p>
<p>跟刷rom一样，进recovery选择opengapps包安装，清cache和dalvik即可。</p>
<p>今天刷pico的opengapps后启动会一直报<code>setup wizard has stopped working</code>，网上找到<a href="https://www.reddit.com/r/cyanogenmod/comments/3wv9t4/setup_wizard_has_stopped_loop/" target="_blank" rel="external">解决方法</a>:</p>
<ul>
<li>adb执行：<code>adb shell pm grant &quot;com.google.android.setupwizard&quot; android.permission.READ_PHONE_STATE</code></li>
<li>到<code>setting - apps</code>，给google service的相关app授权</li>
</ul>
<p>=================== 分割线 =======================</p>
<p>暂时记录到这，随笔记录可能有误。刷机有风险，请谨慎。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于洁癖，相对于MIUI，更喜欢原生的Android系统，更干净更安全。&lt;/p&gt;
&lt;p&gt;今天手贱更新opengapps的时候，把手机刷无限重启了，recovery也进不了，只能重新线刷。借此机会记录一下。&lt;/p&gt;
&lt;h2 id=&quot;rom选择&quot;&gt;&lt;a href=&quot;#rom选择&quot; class=&quot;headerlink&quot; title=&quot;rom选择&quot;&gt;&lt;/a&gt;rom选择&lt;/h2&gt;&lt;p&gt;到国外最流行的Android发烧友论坛&lt;a href=&quot;http://forum.xda-developers.com&quot;&gt;xdadevelopers&lt;/a&gt;找到对应版块，如红米2的 &lt;a href=&quot;http://forum.xda-developers.com/redmi-2/development&quot;&gt;http://forum.xda-developers.com/redmi-2/development&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;浏览一下rom的更新时间、遗留问题、最后几页的讨论，选择自己觉得比较稳妥的rom，毕竟换不同类型的rom是要清SD卡，重新安装配置软件，很麻烦，谁也不想经常这样。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.goorockey.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.goorockey.com/tags/Android/"/>
    
      <category term="redmi2" scheme="http://www.goorockey.com/tags/redmi2/"/>
    
  </entry>
  
  <entry>
    <title>openwrt中使用ngrok</title>
    <link href="http://www.goorockey.com/2016/07/26/try-ngrok-in-openwrt/"/>
    <id>http://www.goorockey.com/2016/07/26/try-ngrok-in-openwrt/</id>
    <published>2016-07-25T16:53:00.000Z</published>
    <updated>2021-08-09T15:53:17.696Z</updated>
    
    <content type="html"><![CDATA[<p>由于所在网络没有公网IP，不能弄DDNS，想要在外面控制家里的openwrt路由，想到用内网穿透神器<a href="https://ngrok.com/" target="_blank" rel="external">ngrok</a>。</p>
<p>ngrok跟Teamviewer等的原理类似，内网的机子主动跟外网的机子保持连接，从而使内网机子“暴露”出外网。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>需要以下资源：</p>
<ul>
<li>域名，可修改其DNS记录</li>
<li>openwrt路由</li>
<li>vps，有公网IP，如：10.0.10.1</li>
</ul>
<a id="more"></a>
<h2 id="DNS设置"><a href="#DNS设置" class="headerlink" title="DNS设置"></a>DNS设置</h2><p>使用ngrok需要通过域名定位到对应的服务。假设我们使用ngrokd.goorockey.com，则需要在goorockey.com中增加两个DNS记录</p>
<pre><code>ngrokd.goorockey.com A 10.0.10.1
*.ngrokd.goorockey.com A 10.0.10.1
</code></pre><p>其中<code>10.0.10.1</code>为所拥有的vps的ip。注意需要添加第二条的泛解析，因为ngrok的http/https，需要子域名定位服务。</p>
<h2 id="编译ngrok-for-openwrt"><a href="#编译ngrok-for-openwrt" class="headerlink" title="编译ngrok for openwrt"></a>编译ngrok for openwrt</h2><p>获取ngrok在openwrt的源码</p>
<pre><code>git clone https://github.com/dosgo/ngrok-c
</code></pre><p>在openwrt官网下载<a href="https://downloads.openwrt.org/" target="_blank" rel="external">https://downloads.openwrt.org/</a>对应路由的SDK，如我的小米路由mini为：</p>
<pre><code>wget -O openwrt-sdk.tar.bz2 https://downloads.openwrt.org/chaos_calmer/15.05.1/ramips/mt7620/OpenWrt-SDK-15.05.1-ramips-mt7620_gcc-4.8-linaro_uClibc-0.9.33.2.Linux-x86_64.tar.bz2
tar xvf openwrt-sdk.tar.bz2
</code></pre><p>复制ngrok-c里面的openssl目录到openwrt-sdk指定目录下</p>
<pre><code>cp -r ngrok-c/include/openssl openwrt-sdk/staging_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-0.9.33.2/include
</code></pre><p>修改ngrok-c里面的<code>openwrtbuildv2.sh</code>，添加<code>openwrt-sdk/staging_dir/toolchain-mipsel_24kec+dsp_gcc-4.8-linaro_uClibc-0.9.33.2/bin</code>到PATH，修改<code>STAGING_DIR</code>为对应目录，查看openwrt的bin目录，修改对应的<code>CC</code>，如<code>mipsel-openwrt-linux-g++</code></p>
<p>执行<code>openwrtbuildv2.sh</code>，在<code>build-mips</code>目录得到<code>ngrokc</code>，即为openwrt的ngrok客户端</p>
<p>把ngrokc复制到路由内，可能还需要路由安装<code>libstdcpp</code></p>
<h2 id="ngrok-server"><a href="#ngrok-server" class="headerlink" title="ngrok server"></a>ngrok server</h2><p>ubuntu下可以直接<code>apt-get install ngrok-server</code>，其他的可以到ngrok官网下载可执行版本，或者源码编译。源码编译可以修改ngrok服务端的ssl证书，安全性更好。</p>
<h2 id="使用ngrok"><a href="#使用ngrok" class="headerlink" title="使用ngrok"></a>使用ngrok</h2><p>服务端执行:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ngrokd -domain=&quot;ngrokd.goorockey.com&quot; \</div><div class="line">       -httpAddr=&quot;:10001&quot; -httpsAddr=&quot;:10002&quot; \</div><div class="line">       -tunnelAddr=&quot;:10003&quot; -log=/var/log/ngrok.log</div></pre></td></tr></table></figure>
<p>客户端执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ngrokc -SER[Shost:ngrokd.goorockey.com,Sport:10003] \</div><div class="line">       -AddTun[Type:http,Lhost:127.0.0.1,Lport:80,Sdname:test] \</div><div class="line">       -AddTun[Type:https,Lhost:127.0.0.1,Lport:443,Sdname:test2] \</div><div class="line">       -AddTun[Type:tcp,Lhost:127.0.0.1,Lport:22,Rport:10004]</div></pre></td></tr></table></figure>
<p>其中<code>10003</code>是服务端指定的ngrok服务监听端口，<code>10001</code>是服务端指定访问http服务时的端口，<code>10002</code>是服务端指定访问https服务时的端口<br><code>10004</code>是客户端指定tcp服务绑定到服务端的端口</p>
<p>以上命令就可以达到：</p>
<ul>
<li>访问<code>http://test.ngrokd.goorockey.com:10001</code>，能访问到路由在80端口的http服务</li>
<li>访问<code>https://test2.ngrokd.goorockey.com:10002</code>，能访问到路由在443端口的https服务</li>
<li>访问<code>tcp://ngrokd.goorockey</code>，端口10004，能访问到路由在22端口的tcp服务，如路由22端口是ssh，则可以ssh ngrokd.goorockey.com -p 10004</li>
</ul>
<p>其他更多选项可参考<a href="https://ngrok.com/" target="_blank" rel="external">ngrok官网</a>和<a href="https://github.com/dosgo/ngrok-c" target="_blank" rel="external">ngrok-c的仓库</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>ngrok的服务端原生是不支持验证的，即ngrokd服务端外放后，其他人的ngrok客户端可以自由连接。</p>
<p>暂时找到两个解决方案：</p>
<ul>
<li>修改源码，参考<a href="https://github.com/inconshreveable/ngrok/issues/321" target="_blank" rel="external">Issue #321</a></li>
<li>使用官方付费的<a href="https://ngrok.com/product/ngrok-link" target="_blank" rel="external">ngrok-link</a></li>
</ul>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li><a href="https://ngrok.com/" target="_blank" rel="external">https://ngrok.com/</a></li>
<li><a href="http://www.jianshu.com/p/8428949d946c" target="_blank" rel="external">http://www.jianshu.com/p/8428949d946c</a></li>
<li><a href="https://github.com/dosgo/ngrok-c/blob/master/README.md" target="_blank" rel="external">https://github.com/dosgo/ngrok-c/blob/master/README.md</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于所在网络没有公网IP，不能弄DDNS，想要在外面控制家里的openwrt路由，想到用内网穿透神器&lt;a href=&quot;https://ngrok.com/&quot;&gt;ngrok&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;ngrok跟Teamviewer等的原理类似，内网的机子主动跟外网的机子保持连接，从而使内网机子“暴露”出外网。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h2&gt;&lt;p&gt;需要以下资源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;域名，可修改其DNS记录&lt;/li&gt;
&lt;li&gt;openwrt路由&lt;/li&gt;
&lt;li&gt;vps，有公网IP，如：10.0.10.1&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.goorockey.com/categories/linux/"/>
    
    
      <category term="openwrt" scheme="http://www.goorockey.com/tags/openwrt/"/>
    
      <category term="ngrok" scheme="http://www.goorockey.com/tags/ngrok/"/>
    
      <category term="linux" scheme="http://www.goorockey.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>使用n管理nodejs</title>
    <link href="http://www.goorockey.com/2015/11/01/use-n-to-manage-node/"/>
    <id>http://www.goorockey.com/2015/11/01/use-n-to-manage-node/</id>
    <published>2015-10-31T16:11:30.000Z</published>
    <updated>2021-08-09T15:53:17.696Z</updated>
    
    <content type="html"><![CDATA[<p>n和nvm都是大家常用的nodejs版本管理工具，最先接触的是n，所以我一般用n。(BTW, n还是TJ大神的项目咧~)</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>以前需要先安装npm才能安装n，现在n有了独立的安装工具<a href="https://github.com/mklement0/n-install" target="_blank" rel="external">n-install</a>，可以通过以下命令安装:</p>
<pre><code>curl -L http://git.io/n-install | bash
</code></pre><p>另外还可以用<code>n-update</code>更新n，<code>n-uninstall</code>卸载n(其实就是删除n的目录和环境变量设置)</p>
<a id="more"></a>
<h2 id="加速"><a href="#加速" class="headerlink" title="加速"></a>加速</h2><p>用法就不说了，<code>n help</code>说明都比较清晰。记录一下使用淘宝镜像加速n对nodejs的包下载。</p>
<p>n支持<code>n project</code>命令，通过设置<code>PROJECT_NAME</code>和<code>PROJECT_URL</code>环境变量，指定下载nodejs包的源。国内从原始官方下载真的太慢了。通过以下命令使用淘宝镜像加速：</p>
<pre><code>PROJECT_NAME=&quot;node&quot; PROJECT_URL=&quot;https://npm.taobao.org/mirrors/node/&quot; n project stable
PROJECT_NAME=&quot;io&quot; PROJECT_URL=&quot;https://npm.taobao.org/mirrors/iojs/&quot; n project stable
</code></pre><p>中间可能会遇到提示<code>Invalid version XXX</code>的问题，如这个<a href="https://github.com/tj/n/issues/314" target="_blank" rel="external">Issue</a>。原始是n脚本在下载包前，用curl或wget先测试链接时候有效:</p>
<p><a href="https://github.com/tj/n/blob/1388dd0926abfa5c21228acbdb33795bee7c5d9d/bin/n#L502" target="_blank" rel="external">502行</a>:</p>
<pre><code>is_ok $url || abort &quot;invalid version $version&quot;
</code></pre><p><a href="https://github.com/tj/n/blob/1388dd0926abfa5c21228acbdb33795bee7c5d9d/bin/n#L360" target="_blank" rel="external">360行</a>:</p>
<pre><code>is_ok() {
  if command -v curl &gt; /dev/null; then
    $GET -Is $1 | head -n 1 | grep 200 &gt; /dev/null
  else
    $GET -S --spider 2&gt;&amp;1 $1 | head -n 1 | grep 200 &gt; /dev/null
  fi
}
</code></pre><p>这里淘宝镜像貌似返回了302重定向，所以is_ok返回失败。保证版本有效的前提下，暂时注释掉502行可以解决问题。当然改grep也可以~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;n和nvm都是大家常用的nodejs版本管理工具，最先接触的是n，所以我一般用n。(BTW, n还是TJ大神的项目咧~)&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;以前需要先安装npm才能安装n，现在n有了独立的安装工具&lt;a href=&quot;https://github.com/mklement0/n-install&quot;&gt;n-install&lt;/a&gt;，可以通过以下命令安装:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;curl -L http://git.io/n-install | bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外还可以用&lt;code&gt;n-update&lt;/code&gt;更新n，&lt;code&gt;n-uninstall&lt;/code&gt;卸载n(其实就是删除n的目录和环境变量设置)&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="http://www.goorockey.com/categories/nodejs/"/>
    
    
      <category term="programming" scheme="http://www.goorockey.com/tags/programming/"/>
    
      <category term="nodejs" scheme="http://www.goorockey.com/tags/nodejs/"/>
    
      <category term="n" scheme="http://www.goorockey.com/tags/n/"/>
    
  </entry>
  
  <entry>
    <title>electron使用总结</title>
    <link href="http://www.goorockey.com/2015/10/12/try-electron/"/>
    <id>http://www.goorockey.com/2015/10/12/try-electron/</id>
    <published>2015-10-12T14:38:57.000Z</published>
    <updated>2021-08-09T15:53:17.696Z</updated>
    
    <content type="html"><![CDATA[<p>帮人做个简单的文件整理程序，尝试用<a href="http://electron.atom.io/" target="_blank" rel="external">electron</a>来实现，总结一下。</p>
<h2 id="主进程和渲染进程"><a href="#主进程和渲染进程" class="headerlink" title="主进程和渲染进程"></a>主进程和渲染进程</h2><p>electron的程序运行时，分为主进程和渲染进程。主进程即为<code>var app = require(&#39;app&#39;);</code>所在一侧，也是程序的入口。通过<code>BrowserWindow</code>实例<code>loadUrl</code>访问网页时，会创建出渲染进程。</p>
<p>某些包是只有主进程才能包含的，如常用的<code>dialog</code>。想在渲染进程的逻辑中调用这些包，有两个方法，一个是使用<code>remote</code>包，如：</p>
<pre><code>var remote = require(&apos;remote&apos;);
var dialog = remote.require(&apos;dialog&apos;);
</code></pre><p>另一个方法是使用<code>ipc</code>，即进程通信，发消息给主进程，由主进程调用后，把结果再通过<code>ipc</code>返回渲染进程。</p>
<a id="more"></a>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>用<a href="https://github.com/maxogden/electron-packager" target="_blank" rel="external">electron-packager</a>打包生成各平台的程序，还是很方便的，但是有些坑。</p>
<h3 id="速度慢"><a href="#速度慢" class="headerlink" title="速度慢"></a>速度慢</h3><p>对某个平台第一次打包的时候，packager需要下载对应的electron包，那速度真是慢啊！</p>
<p>幸好淘宝有electron<a href="http://npm.taobao.org/mirrors" target="_blank" rel="external">镜像</a>。通过设置<code>ELECTRON_MIRROR</code>环境变量，可以大大加快速度。</p>
<pre><code>ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/ electron-packager ...
</code></pre><h3 id="体积大"><a href="#体积大" class="headerlink" title="体积大"></a>体积大</h3><p>electron打包出来的程序，一般至少100M，对于一个小程序来说有点太大了，体积问题感觉是很多跨平台工具的通病。</p>
<p>为了减少体积，记得使用packager的ignore参数，排除掉例如electron等程序运行不必要的包，如果指定了packager的输出路径在程序的目录，记得也排除掉，不然会越打包越大。</p>
<p>最后我使用的打包命令如下：</p>
<pre><code>electron-packager . &lt;程序名字&gt; --platform=win32,darwin --arch=all --version=0.33.7 --out=dist/ --overwrite --ignore=node_modules/electron-* --ignore=node_modules/.bin --ignore=.git --ignore=dist --prune
</code></pre><p>把命令写在<code>package.json</code>的<code>scripts</code>里，比如<code>package</code>命令，则打包时运行：</p>
<pre><code>ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron/ npm run package
</code></pre><h2 id="electron一些资源"><a href="#electron一些资源" class="headerlink" title="electron一些资源"></a>electron一些资源</h2><ul>
<li><a href="http://electron.atom.io/docs/latest/" target="_blank" rel="external">官方文档</a></li>
<li><a href="https://github.com/ilyavorobiev/atom-docs/blob/master/atom-shell/Architecture.md" target="_blank" rel="external">electron内部结构</a></li>
<li><a href="https://github.com/sindresorhus/awesome-electron" target="_blank" rel="external">awesome-electron</a></li>
<li><a href="https://github.com/hokein/electron-sample-apps" target="_blank" rel="external">electron-sample-apps</a></li>
</ul>
<p>用得还不够深入，之后遇到更多问题再补充。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;帮人做个简单的文件整理程序，尝试用&lt;a href=&quot;http://electron.atom.io/&quot;&gt;electron&lt;/a&gt;来实现，总结一下。&lt;/p&gt;
&lt;h2 id=&quot;主进程和渲染进程&quot;&gt;&lt;a href=&quot;#主进程和渲染进程&quot; class=&quot;headerlink&quot; title=&quot;主进程和渲染进程&quot;&gt;&lt;/a&gt;主进程和渲染进程&lt;/h2&gt;&lt;p&gt;electron的程序运行时，分为主进程和渲染进程。主进程即为&lt;code&gt;var app = require(&amp;#39;app&amp;#39;);&lt;/code&gt;所在一侧，也是程序的入口。通过&lt;code&gt;BrowserWindow&lt;/code&gt;实例&lt;code&gt;loadUrl&lt;/code&gt;访问网页时，会创建出渲染进程。&lt;/p&gt;
&lt;p&gt;某些包是只有主进程才能包含的，如常用的&lt;code&gt;dialog&lt;/code&gt;。想在渲染进程的逻辑中调用这些包，有两个方法，一个是使用&lt;code&gt;remote&lt;/code&gt;包，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var remote = require(&amp;apos;remote&amp;apos;);
var dialog = remote.require(&amp;apos;dialog&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一个方法是使用&lt;code&gt;ipc&lt;/code&gt;，即进程通信，发消息给主进程，由主进程调用后，把结果再通过&lt;code&gt;ipc&lt;/code&gt;返回渲染进程。&lt;/p&gt;
    
    </summary>
    
      <category term="nodejs" scheme="http://www.goorockey.com/categories/nodejs/"/>
    
    
      <category term="programming" scheme="http://www.goorockey.com/tags/programming/"/>
    
      <category term="electron" scheme="http://www.goorockey.com/tags/electron/"/>
    
      <category term="nodejs" scheme="http://www.goorockey.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Python按位运算结果跟Js不同</title>
    <link href="http://www.goorockey.com/2015/09/30/python-bitwise-difference-with-javascript/"/>
    <id>http://www.goorockey.com/2015/09/30/python-bitwise-difference-with-javascript/</id>
    <published>2015-09-30T09:54:00.000Z</published>
    <updated>2021-08-09T15:53:17.695Z</updated>
    
    <content type="html"><![CDATA[<p>由于python的整型是64位的，js的是32位，所以前后端通信的时候，会出现两边按位运算结果不同导致有问题。</p>
<p>解决是用python中ctypes的c_int32等类型，如:</p>
<pre><code>[javascript]
&gt; i = 1443603316765
&gt; ~i
-494305310

[python]
&gt;&gt;&gt; import ctypes
&gt;&gt;&gt; i = 1443603316765
&gt;&gt;&gt; ~i
-1443603316766
&gt;&gt;&gt; (ctypes.c_int32(~i).value)
-494305310
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于python的整型是64位的，js的是32位，所以前后端通信的时候，会出现两边按位运算结果不同导致有问题。&lt;/p&gt;
&lt;p&gt;解决是用python中ctypes的c_int32等类型，如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[javascript]
&amp;gt; i = 14436
    
    </summary>
    
      <category term="programming" scheme="http://www.goorockey.com/categories/programming/"/>
    
    
      <category term="js" scheme="http://www.goorockey.com/tags/js/"/>
    
      <category term="python" scheme="http://www.goorockey.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>查看所有子域名</title>
    <link href="http://www.goorockey.com/2015/09/21/list-dns-subdomain/"/>
    <id>http://www.goorockey.com/2015/09/21/list-dns-subdomain/</id>
    <published>2015-09-21T12:39:53.000Z</published>
    <updated>2021-08-09T15:53:17.695Z</updated>
    
    <content type="html"><![CDATA[<p>有时候想查看一个域名的所有子域名，纯dig是办不到的。</p>
<p>一般的做法就是穷举，类似像dnspod等DNS域名管理服务，应该有个白名单，所以当我们添加域名的时候，能找到常用的子域名。</p>
<p>不想自己穷举，可以用在线的工具，如: <a href="https://pentest-tools.com/information-gathering/find-subdomains-of-domain" target="_blank" rel="external">https://pentest-tools.com/information-gathering/find-subdomains-of-domain</a></p>
<p>还找到个工具，看说明挺有效的样子，可以避免被认为恶意攻击: <a href="https://github.com/TheRook/subbrute" target="_blank" rel="external">https://github.com/TheRook/subbrute</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候想查看一个域名的所有子域名，纯dig是办不到的。&lt;/p&gt;
&lt;p&gt;一般的做法就是穷举，类似像dnspod等DNS域名管理服务，应该有个白名单，所以当我们添加域名的时候，能找到常用的子域名。&lt;/p&gt;
&lt;p&gt;不想自己穷举，可以用在线的工具，如: &lt;a href=&quot;https
    
    </summary>
    
      <category term="others" scheme="http://www.goorockey.com/categories/others/"/>
    
    
      <category term="dns" scheme="http://www.goorockey.com/tags/dns/"/>
    
  </entry>
  
  <entry>
    <title>美剧自动保存到百度盘</title>
    <link href="http://www.goorockey.com/2015/09/08/drama-downloader/"/>
    <id>http://www.goorockey.com/2015/09/08/drama-downloader/</id>
    <published>2015-09-08T03:45:07.000Z</published>
    <updated>2021-08-09T15:53:17.695Z</updated>
    
    <content type="html"><![CDATA[<p>现在习惯每周的美剧都用百度盘的离线下载，然后回家在Pad或者电脑看。</p>
<p>这样每周看美剧是否更新，把链接复制到离线下载就成了机械工作，所以写了个脚本来自动化搞定。</p>
<p>Github: <a href="https://github.com/goorockey/drama-downloader" target="_blank" rel="external">https://github.com/goorockey/drama-downloader</a></p>
<a id="more"></a>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>每天定时到指定网址检查美剧的更新</li>
<li>解析出更新链接</li>
<li>添加百度盘的离线任务</li>
</ul>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul>
<li>百度盘的操作，用了<a href="https://github.com/ly0/baidupcsapi" target="_blank" rel="external">ly0/baidupcsapi</a></li>
<li>自动识别验证码，用了<a href="http://cloudsightapi.com" target="_blank" rel="external">Cloudsight</a></li>
<li>解析链接，用了<a href="https://en.wikipedia.org/wiki/XPath" target="_blank" rel="external">XPATH</a></li>
<li>python生成exe，用了<a href="https://github.com/pyinstaller/pyinstaller/wiki" target="_blank" rel="external">pyinstaller</a></li>
</ul>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>用pyinstaller生成exe后，运行会报<code>SSLError: no such file or directory</code>，原因是requests库的SSL证书没找到。</p>
<p>参考<a href="https://github.com/kennethreitz/requests/issues/557" target="_blank" rel="external">https://github.com/kennethreitz/requests/issues/557</a>，把requests的<code>cacert.pem</code>放到代码目录，并在代码开头加上以下代码解决问题:</p>
<pre><code>os.environ[&apos;REQUESTS_CA_BUNDLE&apos;] = os.path.join(
  os.path.dirname(os.path.abspath(__file__)),
  &apos;cacert.pem&apos;
)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在习惯每周的美剧都用百度盘的离线下载，然后回家在Pad或者电脑看。&lt;/p&gt;
&lt;p&gt;这样每周看美剧是否更新，把链接复制到离线下载就成了机械工作，所以写了个脚本来自动化搞定。&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/goorockey/drama-downloader&quot;&gt;https://github.com/goorockey/drama-downloader&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.goorockey.com/categories/python/"/>
    
    
      <category term="programming" scheme="http://www.goorockey.com/tags/programming/"/>
    
      <category term="python" scheme="http://www.goorockey.com/tags/python/"/>
    
      <category term="美剧" scheme="http://www.goorockey.com/tags/%E7%BE%8E%E5%89%A7/"/>
    
      <category term="百度盘" scheme="http://www.goorockey.com/tags/%E7%99%BE%E5%BA%A6%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Node.js高并发配置</title>
    <link href="http://www.goorockey.com/2014/07/20/high-concurrency-setting-for-nodejs/"/>
    <id>http://www.goorockey.com/2014/07/20/high-concurrency-setting-for-nodejs/</id>
    <published>2014-07-19T16:00:00.000Z</published>
    <updated>2021-08-09T15:53:17.700Z</updated>
    
    <content type="html"><![CDATA[<p>node.js的异步模型让它很擅长实现IO密集型的系统，但是测试发现，当并发真的上到几W的时候，会有处理不过来的情况。除了从整个系统的设计上改进，还需要修改一些配置。这里总结一下为了让node.js应对高并发，需要做的配置。</p>
<a id="more"></a>
<p>###linux系统配置</p>
<p>修改/etc/sysctl.conf，情况文件内默认的内容，写入以下项，保存后执行<code>sudo sysctl -p</code>使配置生效。注意里面的数值要根据具体情况修改。这些修改当然也适用于除node.js以为的应用。</p>
<pre><code>net.ipv4.ip_local_port_range = 10240 65535
net.core.rmem_max=16777216
net.core.wmem_max=16777216
net.ipv4.tcp_rmem=4096 8738 16777216
net.ipv4.tcp_wmem=4096 8738 16777216
net.ipv4.tcp_fin_timeout = 40
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_timestamps = 0
net.ipv4.tcp_window_scaling = 0
net.ipv4.tcp_sack = 0
net.core.netdev_max_backlog = 30000
net.ipv4.tcp_no_metrics_save=1
net.core.somaxconn = 65535
net.ipv4.tcp_syncookies = 0
net.ipv4.tcp_max_orphans = 262144
net.ipv4.tcp_max_syn_backlog = 819200
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_syn_retries = 2
net.ipv4.tcp_max_tw_buckets = 65535
</code></pre><ul>
<li><p><code>net.ipv4.ip_local_port_range</code> 可用端口范围，从第一个值到第二个值。默认的”1024 4999”很容易不够。</p>
</li>
<li><p><code>net.ipv4.tcp_tw_reuse</code> 是否让系统在安全情况下重用TIME_WAIT状态的连接。在高并发情况下，有大量的连接建立和关闭，TIME_WAIT的连接是快要关闭、但资源还没有回收的，像内存、端口都会占用着。</p>
</li>
<li><p><code>net.ipv4.tcp_max_tw_buckets</code> 维持TIME_WAIT状态最多连接数。当超过这个值时，连接就会立刻关闭，并报错，dmesg可以看到。</p>
</li>
<li><p><code>net.ipv4.tcp_fin_timeout</code> TIME_WAIT状态的连接回收时的等待时长。</p>
</li>
<li><p><code>net.ipv4.tcp_max_syn_backlog</code> 最多记录接受到多少SYN。</p>
</li>
<li><p><code>net.ipv4.tcp_rmem</code> tcp读缓存空间，三个值分别是最小、默认和最大。</p>
</li>
<li><p><code>net.ipv4.tcp_wmem</code> tcp写缓存空间，三个值分别是最小、默认和最大。</p>
</li>
<li><p><code>net.core.somaxconn</code> 最大连接数</p>
</li>
</ul>
<p>修改/etc/security/limits.conf，提高文件句柄上限:</p>
<pre><code>soft nofile 65536
hard nofile 65536
</code></pre><p>###socket池</p>
<p>nodejs的http模块内置socket池，默认<a href="http://nodejs.org/api/http.html#http_agent_maxsockets" target="_blank" rel="external">最多建立5个socket</a></p>
<pre><code>require(&apos;http&apos;).globalAgent.maxSockets = 40000 # 也可以设成Infinity，无限制
require(&apos;https&apos;).globalAgent.maxSockets = 40000
</code></pre><p>###垃圾回收</p>
<p>nodejs会周期性地向V8发出垃圾回收请求，在并发大的时候经常这样会过多地占用CPU。可以通过启动node时加入<code>--nouse-idle-notification</code>选项，关闭这个动作。如:</p>
<pre><code>node --nouse-idle-notification app.js
</code></pre><p>###多进程</p>
<p>nodejs虽然异步可以处理轻松地处理大量请求，但单进程单线程的模型在多核下还没有完全利用硬件资源。幸好nodejs原生的<a href="http://nodejs.org/api/cluster.html" target="_blank" rel="external">cluster模块</a>可以很简单地让程序编程多进程。</p>
<p>cluster是prefork模型的，即前面一个master负责总的接受请求，然后均匀地把请求分发给worker，每个worker是一个独立的进程。<br>例如对于express的应用，在程序入口添加以下代码即可：</p>
<pre><code>var express = require(&apos;express&apos;);
...

if (cluster.isMaster) {
  // calculate number of proccesses to fork
  var num_cpus = require(&apos;os&apos;).cpus().length;
  var num_processes = Math.max(1, num_cpus - 1);

  debug(&apos;Master starts with %d processes.&apos;, num_processes);
  for (var i = 0; i &lt; num_processes; i++) {
    cluster.fork();
  }

  // Listen for dying processes
  cluster.on(&apos;exit&apos;, function(worker, code, signal) {
    debug(&apos;A process(pid=%s) of master died (%s). Restarting...&apos;,
          worker.process.pid, signal || code);
    cluster.fork();
  });

  return;
}

// worker
var app = express();
...
</code></pre><p>另外还有如<a href="https://github.com/Unitech/pm2" target="_blank" rel="external">PM2</a>等外部工具可以让原来单进程的程序变成多进程</p>
<p>###参考资料</p>
<ul>
<li><p><a href="http://www.oschina.net/translate/optimising-nginx-node-js-and-networking-for-heavy-workloads" target="_blank" rel="external">http://www.oschina.net/translate/optimising-nginx-node-js-and-networking-for-heavy-workloads</a></p>
</li>
<li><p><a href="http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/" target="_blank" rel="external">http://blog.caustik.com/2012/04/08/scaling-node-js-to-100k-concurrent-connections/</a></p>
</li>
<li><p><a href="http://engineering.linkedin.com/nodejs/blazing-fast-nodejs-10-performance-tips-linkedin-mobile" target="_blank" rel="external">http://engineering.linkedin.com/nodejs/blazing-fast-nodejs-10-performance-tips-linkedin-mobile</a></p>
</li>
<li><p><a href="https://rtcamp.com/tutorials/linux/sysctl-conf/" target="_blank" rel="external">https://rtcamp.com/tutorials/linux/sysctl-conf/</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;node.js的异步模型让它很擅长实现IO密集型的系统，但是测试发现，当并发真的上到几W的时候，会有处理不过来的情况。除了从整个系统的设计上改进，还需要修改一些配置。这里总结一下为了让node.js应对高并发，需要做的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="programming" scheme="http://www.goorockey.com/categories/programming/"/>
    
    
      <category term="programming" scheme="http://www.goorockey.com/tags/programming/"/>
    
      <category term="nodejs" scheme="http://www.goorockey.com/tags/nodejs/"/>
    
      <category term="high concurrency" scheme="http://www.goorockey.com/tags/high-concurrency/"/>
    
  </entry>
  
  <entry>
    <title>消息队列方案粗略调研</title>
    <link href="http://www.goorockey.com/2014/06/09/survey-of-message-queue/"/>
    <id>http://www.goorockey.com/2014/06/09/survey-of-message-queue/</id>
    <published>2014-06-08T16:00:00.000Z</published>
    <updated>2021-08-09T15:53:17.704Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做的系统准备加个消息队列，重构成“master-queue-workers”的结构.</p>
<p>感觉现在好多系统都是这个结构。这样master就专心接受用户的请求，把任务放进队列，让workers去处理。master就可以立刻回复用户，而不用等待处理完整个业务才回复。</p>
<p>主流的消息队列方案可以看<a href="http://queues.io/" target="_blank" rel="external">这里</a>。</p>
<p>我主要考虑的方案有rabbitMQ、redis、celery、mongodb。</p>
<a id="more"></a>
<ul>
<li><p><code>rabbitMQ</code>： 之前在学erlang的时候就知道rabbitMQ，它在消息或任务队列里面是主流的方案，成熟稳定。同类的还有ZeroMQ等。</p>
<p>  <strong>优点</strong>：成熟放心。</p>
<p>  <strong>缺点</strong>：需要开发和运维都充分掌握，学习和维护成本较redis的高。</p>
</li>
<li><p><code>redis</code>：内部的列表支持对队列的操作，其中List的blpop是阻塞式的，满足消息队列的要求。</p>
<p>  <strong>优点</strong>：使用和维护简单。自身的内存缓存特点也保证了速度。</p>
<p>  <strong>缺点</strong>：因为不是原生设计成对消息队列的应用，有的队列操作还需要补充实现。这个有现成的库可以帮助解决，但可靠性、成熟度需要确认。</p>
</li>
<li><p><code>celery</code>：把rabbiMQ、redis、mongodb等作为后端，进一步的封装。最初是python的，现在也有nodejs版</p>
<p>  <strong>优点</strong>：进一步的封装，可以方便把后端切换成不同的方案。python版相对比较成熟。</p>
<p>  <strong>缺点</strong>：nodejs版还不够成熟，有点功能还不支持，比如底层现在指支持rabbitMQ，不支持redis</p>
</li>
<li><p><code>mongodb</code>: 其实也有人用mongodb的capped collection来做队列，鉴于它在node.js的应用中广泛被使用，它也是一种选择。</p>
<p>  <strong>优点</strong>：如果本来应用就是用mongodb，那可以一并来用</p>
<p>  <strong>缺点</strong>：当并发量大的时候，速度不理想</p>
</li>
</ul>
<p>我最后选择了用redis。因为系统是用node.js写的，所有用到了node的<a href="https://github.com/LearnBoost/kue" target="_blank" rel="external">kue</a>库。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做的系统准备加个消息队列，重构成“master-queue-workers”的结构.&lt;/p&gt;
&lt;p&gt;感觉现在好多系统都是这个结构。这样master就专心接受用户的请求，把任务放进队列，让workers去处理。master就可以立刻回复用户，而不用等待处理完整个业务才回复。&lt;/p&gt;
&lt;p&gt;主流的消息队列方案可以看&lt;a href=&quot;http://queues.io/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我主要考虑的方案有rabbitMQ、redis、celery、mongodb。&lt;/p&gt;
    
    </summary>
    
      <category term="programming" scheme="http://www.goorockey.com/categories/programming/"/>
    
    
      <category term="programming" scheme="http://www.goorockey.com/tags/programming/"/>
    
      <category term="nodejs" scheme="http://www.goorockey.com/tags/nodejs/"/>
    
      <category term="redis" scheme="http://www.goorockey.com/tags/redis/"/>
    
      <category term="queue" scheme="http://www.goorockey.com/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>用nodejs实现Instapaper回顾邮件自动发送</title>
    <link href="http://www.goorockey.com/2014/05/12/instapaper-review/"/>
    <id>http://www.goorockey.com/2014/05/12/instapaper-review/</id>
    <published>2014-05-11T16:00:00.000Z</published>
    <updated>2021-08-09T15:53:17.700Z</updated>
    
    <content type="html"><![CDATA[<p>最近在搞nodejs，刚好有个点子，想实现一个对自己这个月在<a href="http://www.instapaper.com" title="Instapaper" target="_blank" rel="external">Instapaper</a>的已读文章做回顾，通过邮件形式发到自己的邮箱，起到复习的作用。然后上周末就用了两个通宵把这搞出来了，代码放在<a href="https://github.com/goorockey/instapaper-review" target="_blank" rel="external">Github</a>上面。</p>
<p>###总的情况</p>
<ul>
<li>整个服务跑在<a href="http://www.appfog.com" title="Appfog" target="_blank" rel="external">Appfog</a>上</li>
<li>用<a href="http://sendgrid.com" title="SendGrid" target="_blank" rel="external">SendGrid</a>服务发送邮件</li>
<li>nodejs实现, 用到了cheerio、request、cron、sugar、ejs、sendgrid等几个模块</li>
</ul>
<a id="more"></a>
<p>###抓文章</p>
<p>Instapaper提供有API，可以获取到已读文章，但它需要填表、人工审核，感觉不容易通过，索性就自己模拟登录，抓下来算了。F12看了一下，发现Instapaper通信协议极其简单，好抓得很。</p>
<p>nodejs抓网页，可以用cheerio，说比传统的JSDOM要快、要方便，用着确实方便。</p>
<p>###Appfog</p>
<p>Appfog是我挺喜欢的一个PaaS，它是基于Cloudary提供服务的，支持语言多，部署简单。</p>
<p>这次因为要定时发邮件，在Appfog上面要定时执行，需要部署一个<a href="http://blog.appfog.com/task-scheduling-support-on-appfog-with-standalone-apps/" target="_blank" rel="external">standalone app</a>。</p>
<p>nodejs这边要实现定时，要node-cron很方便就搞定了。</p>
<p>###发邮件</p>
<p>Appfog上面提供SendGrid的插件。SendGrid在全球提供发邮件服务，为了防止垃圾邮件，其申请时的审核挺严格的。不过在Appfog上面想用SendGrid就简单得多，把插件启动了就好了，赞！</p>
<p>###nodejs</p>
<p>用nodejs的异步回调机制开发，确实要转一下思维。有时候循环还不得不写成递归，很函数式语言。</p>
<p>中间遇到一个问题，就是Instapaper上的时间都是用moment.js或者timeago.js之类转成了XXX days ago、XXX months ago的语义式时间。因为我只想回顾最近这个月的文章，要做判断，所以要做逆过程，恢复成日期的。sugarjs这个模块很强大地解决了这个问题~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在搞nodejs，刚好有个点子，想实现一个对自己这个月在&lt;a href=&quot;http://www.instapaper.com&quot; title=&quot;Instapaper&quot;&gt;Instapaper&lt;/a&gt;的已读文章做回顾，通过邮件形式发到自己的邮箱，起到复习的作用。然后上周末就用了两个通宵把这搞出来了，代码放在&lt;a href=&quot;https://github.com/goorockey/instapaper-review&quot;&gt;Github&lt;/a&gt;上面。&lt;/p&gt;
&lt;p&gt;###总的情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整个服务跑在&lt;a href=&quot;http://www.appfog.com&quot; title=&quot;Appfog&quot;&gt;Appfog&lt;/a&gt;上&lt;/li&gt;
&lt;li&gt;用&lt;a href=&quot;http://sendgrid.com&quot; title=&quot;SendGrid&quot;&gt;SendGrid&lt;/a&gt;服务发送邮件&lt;/li&gt;
&lt;li&gt;nodejs实现, 用到了cheerio、request、cron、sugar、ejs、sendgrid等几个模块&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="programming" scheme="http://www.goorockey.com/categories/programming/"/>
    
    
      <category term="nodejs" scheme="http://www.goorockey.com/tags/nodejs/"/>
    
      <category term="Instapaper" scheme="http://www.goorockey.com/tags/Instapaper/"/>
    
      <category term="email" scheme="http://www.goorockey.com/tags/email/"/>
    
  </entry>
  
  <entry>
    <title>用wxWidgets做移植的总结</title>
    <link href="http://www.goorockey.com/2014/04/21/summary-of-using-wxwidgets/"/>
    <id>http://www.goorockey.com/2014/04/21/summary-of-using-wxwidgets/</id>
    <published>2014-04-20T16:00:00.000Z</published>
    <updated>2021-08-09T15:53:17.704Z</updated>
    
    <content type="html"><![CDATA[<p>这几个月做的项目是把一个承载在MFC的软件从Windows移植到Mac，现在进入最后验收阶段了。当时网上调研了一下，决定用<a href="http://www.wxwidgets.org" title="wxWidgets" target="_blank" rel="external">wxWidgets</a>这个跨平台的开源库来帮助移植。总的来说，只要把原软件对Windows API的调用都改为对wxWidgets的调用，基本就完成了移植。但基于wxWidgets和MFC一些设计上的差异和原软件特殊的功能，还不是简单的全局替换就能了事的，甚至还得改wxWidgets的源码。</p>
<p>wxWidgets库在总的结构上跟MFC相似，比如消息响应、相关类的命名。它现在已经出到了3.0，总体还是比较成熟了，但还是好些不完善的地方，这个在看它源码的时候就会发现挺多TODO comment。不过它的官方论坛和stackoverflow上相关问题还是挺活跃的，在上面提问很快就能得到一些资深程序员的答复。有一次我误以为发现了它的一个bug（其实是我理解错了），在上面提问，回复的人不仅有文字的讲解，还附上了自己写的测试用例，让我真心赞叹对方好负责任啊。</p>
<p>现在总结一些项目移植过程中遇到的问题吧。</p>
<a id="more"></a>
<h2 id="wxRect和CRect"><a href="#wxRect和CRect" class="headerlink" title="wxRect和CRect"></a>wxRect和CRect</h2><p>Windows的CRect要替换成wxWidgets的wxRect真不能简单的替换，因为两者内部设计不一样。</p>
<p>第一，两者对应接口的入参有不同，最经典的是两者的构造函数，CRect是传left,top,right,bottom，wxWidgets是传left,top,width,height，等于说所有构造CRect的地方都要把第三、第四个参数做减法。</p>
<p>第二，wxRect定义自己所表示的矩形，范围是[left, right - 1]和[top, bottom - 1]，意思就是右边界和下边界是不属于矩形一部分的，这个从其源码能看到。官方说法是不承认width或height为1的矩形，那应该视为线段。这在移植一些矩形操作时，会跟CRect的有些差异。</p>
<p>第三，也是我觉得最坑的，CRect内部直接保存left,top,right,bottom来定义矩形，而wxRect内部保存left,top,width,height来定义矩形，即wxWidgets要GetRight的时候，是返回left + width，SetRight的时候set的是width，其他的同理。这看着没什么问题。但如果我们先SetRight，再SetLeft，wxRect的行为就跟CRect的不一样了。</p>
<p>例如对一个(left,top,right,bottom)=(1,1,5,5)的CRect，对应的wxRect是(left,top,width,height)=(1,1,4,4)，我们对其依次执行SetRight(10)和SetLeft(3)，得到CRect是(left,top,right,bottom)=(3,1,10,5)，wxRect是(left,top,width,height)=(3,1,9,4)，换算过来wxRect是(left,top,right,bottom)=(3,1,12,5)，跟得到的CRect不同！原因就是SetLeft的时候，wxRect只改left，没改width，但等于right还是改了，其实是使整个矩形做了偏移；CRect的行为则是修改左边界，右边界不会动，其实是使整个矩形做压缩。真是坑啊！注意到这一点之后，原软件每个连续SetLeft、SetRight，SetTop、SetBottom的地方，都要注意执行的顺序。</p>
<p>鉴于wxRect和CRect以上的差异，其实移植的时候最好的做法是自己写一个封装了wxRect的MyRect类，把wxRect和CRect的差异在MyRect里面做转换。这其实是应用了Adaptor Pattern。</p>
<h2 id="Mac下wxBitmap在剪切板wxClipboard取回时，Alpha信息丢失"><a href="#Mac下wxBitmap在剪切板wxClipboard取回时，Alpha信息丢失" class="headerlink" title="Mac下wxBitmap在剪切板wxClipboard取回时，Alpha信息丢失"></a>Mac下wxBitmap在剪切板wxClipboard取回时，Alpha信息丢失</h2><p>wxWidgets在从剪切板wxClipboard取回图片数据wxBitmapDataObject时，会丢失了透明信息，即Alpha channel。具体来看就是原来用RGBA表示的有透明信息的图片，通过剪切板传递之后，RGBA的A都变成255了。</p>
<p>我通过查看wxWidgets的源码，发现确实是个bug，wxWidgets在Mac这边调用Cocoa接口从剪切板获取像素数据保存为图片时，没有关注Alpha channel。这个我通过修改它源码解决了。详见我提交到官方的这个<a href="http://trac.wxwidgets.org/ticket/16198" target="_blank" rel="external">ticket</a>。</p>
<h2 id="wxDC在Unix下不是线程安全的"><a href="#wxDC在Unix下不是线程安全的" class="headerlink" title="wxDC在Unix下不是线程安全的"></a>wxDC在Unix下不是线程安全的</h2><p>wxDC是wxWidgets的绘制上下文，对应于Windows下的CDC。官方资料说了，wxDC在Unix平台下是非线程安全的。这里指的Unix平台具体是GTK(Linux)和OSX(Mac)。所以绘制的时候最好是下wxPaintEvent的响应函数里面做。在子线程做绘制不保证正确，即使是用wxWidgets的wxGuiEnter/wxGuiLeave加锁也是不行。</p>
<h2 id="对话框资源的移植"><a href="#对话框资源的移植" class="headerlink" title="对话框资源的移植"></a>对话框资源的移植</h2><p>在MFC中，对话框资源都保存在rc文件中。而对应到wxWidgets，每个对话框以xml格式保存成各自的xrc文件，跟rc有一定区别。MFC大部分控件在wxWidgets都能找到。对于对话框资源的移植，我们是用脚本批量完成的，中间一个坑是转换时候对话框和控件的大小在MFC的rc和wxWidgets的xrc不是1:1的，要乘一个比例，1.5左右。</p>
<h2 id="ALL-IN-ALL"><a href="#ALL-IN-ALL" class="headerlink" title="ALL IN ALL"></a>ALL IN ALL</h2><p>以上是暂时记得的问题。总的来说，wxWidgets是个强大的跨平台库，用着真心方便，常用的操作也都覆盖了，代码也整洁漂亮，社区也活跃，还是可以放心选用的。而且作为一个开源库，有什么问题都能自己定位自己修改解决，开源万岁～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几个月做的项目是把一个承载在MFC的软件从Windows移植到Mac，现在进入最后验收阶段了。当时网上调研了一下，决定用&lt;a href=&quot;http://www.wxwidgets.org&quot; title=&quot;wxWidgets&quot;&gt;wxWidgets&lt;/a&gt;这个跨平台的开源库来帮助移植。总的来说，只要把原软件对Windows API的调用都改为对wxWidgets的调用，基本就完成了移植。但基于wxWidgets和MFC一些设计上的差异和原软件特殊的功能，还不是简单的全局替换就能了事的，甚至还得改wxWidgets的源码。&lt;/p&gt;
&lt;p&gt;wxWidgets库在总的结构上跟MFC相似，比如消息响应、相关类的命名。它现在已经出到了3.0，总体还是比较成熟了，但还是好些不完善的地方，这个在看它源码的时候就会发现挺多TODO comment。不过它的官方论坛和stackoverflow上相关问题还是挺活跃的，在上面提问很快就能得到一些资深程序员的答复。有一次我误以为发现了它的一个bug（其实是我理解错了），在上面提问，回复的人不仅有文字的讲解，还附上了自己写的测试用例，让我真心赞叹对方好负责任啊。&lt;/p&gt;
&lt;p&gt;现在总结一些项目移植过程中遇到的问题吧。&lt;/p&gt;
    
    </summary>
    
      <category term="programming" scheme="http://www.goorockey.com/categories/programming/"/>
    
    
      <category term="programming" scheme="http://www.goorockey.com/tags/programming/"/>
    
      <category term="cpp" scheme="http://www.goorockey.com/tags/cpp/"/>
    
      <category term="wxwidgets" scheme="http://www.goorockey.com/tags/wxwidgets/"/>
    
  </entry>
  
  <entry>
    <title>用Web-Harvest抓腾讯微博</title>
    <link href="http://www.goorockey.com/2014/03/05/webharvest-4-tweibo/"/>
    <id>http://www.goorockey.com/2014/03/05/webharvest-4-tweibo/</id>
    <published>2014-03-05T13:31:00.000Z</published>
    <updated>2021-08-09T15:53:17.706Z</updated>
    
    <content type="html"><![CDATA[<p>好久没更新博客，水一文。</p>
<p>前阵子要给别人出试题，偶然发现<a href="下称WH">Web-Harvest</a>这个抓网页的工具，它主要应用xpath和xquery抓网页，内置还定义了一套功能挺多的语法，就出了一道用WH抓微博的题目。</p>
<p>本来想抓新浪微博的，但发现它的微博内容都是js生成的，折腾了一下，还是可以用WH的函数提取出内容，但腾讯微博相对还是简单多了。</p>
<p>题目其中一个内容是用WH抓几页邓紫棋的腾讯微博，排除包含她演唱会广告的和没有图片的微博。</p>
<a id="more"></a>
<p>其中遇到的坑：</p>
<ul>
<li><p>因为是包含中文，写入到文件时要用gbk编码</p>
</li>
<li><p>在xpath已经用li[@id]获取微博节点，但节点传到xquery里面时竟然还要再一次用li[@id]获取一级</p>
</li>
</ul>
<p>配置文件如下</p>
<script src="//gist.github.com/9368146.js"></script>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久没更新博客，水一文。&lt;/p&gt;
&lt;p&gt;前阵子要给别人出试题，偶然发现&lt;a href=&quot;下称WH&quot;&gt;Web-Harvest&lt;/a&gt;这个抓网页的工具，它主要应用xpath和xquery抓网页，内置还定义了一套功能挺多的语法，就出了一道用WH抓微博的题目。&lt;/p&gt;
&lt;p&gt;本来想抓新浪微博的，但发现它的微博内容都是js生成的，折腾了一下，还是可以用WH的函数提取出内容，但腾讯微博相对还是简单多了。&lt;/p&gt;
&lt;p&gt;题目其中一个内容是用WH抓几页邓紫棋的腾讯微博，排除包含她演唱会广告的和没有图片的微博。&lt;/p&gt;
    
    </summary>
    
      <category term="programming" scheme="http://www.goorockey.com/categories/programming/"/>
    
    
      <category term="programming" scheme="http://www.goorockey.com/tags/programming/"/>
    
      <category term="Web-Harvest" scheme="http://www.goorockey.com/tags/Web-Harvest/"/>
    
  </entry>
  
  <entry>
    <title>我的firefox</title>
    <link href="http://www.goorockey.com/2013/09/08/my-firefox-config/"/>
    <id>http://www.goorockey.com/2013/09/08/my-firefox-config/</id>
    <published>2013-09-07T16:00:00.000Z</published>
    <updated>2021-08-09T15:53:17.701Z</updated>
    
    <content type="html"><![CDATA[<p>好久好久没有更新blog了，markdown怎么用都忘了。。写blog总结还是很有用的。今天写一下答应过某人写自己firefox的状况。</p>
<p>###使用感受</p>
<p>主流的浏览器都用过，坚持用firefox的原因主要是因为<a href="http://www.vimperator.org" title="vimperator" target="_blank" rel="external">vimperator</a>，纯键盘地上网很cool很快捷，而且我用的时候会把地址栏、add-on bar等等都去掉，最大化可视范围。<br>虽然现在firefox在内存、响应速度上还是比不上chrome，但谁叫chrome的vim化插件不好用呢～</p>
<p>另外用firefox写web的时候也比较方便，现在自带的“Responsive Design View”很方便地调试移动端的web体验。firefox每次升级都会有针对developer的new feature，足以看出它很重视开发者的功能。</p>
<a id="more"></a>
<p>###插件</p>
<p>装插件折腾自己的firefox是必须的。当我看到有的人用firefox基本就是原装的，我都觉得他不适合用firefox，倒不如用另外国产标配好的浏览器让自己用得舒服一点。</p>
<ul>
<li><s><strong>vimperator</strong>    神器</s></li>
<li><strong>Pentadactyl</strong> 神器，vimperator的分支</li>
<li><strong>firebug</strong>   神器</li>
<li><strong>greasemonkey</strong>  神器，firefox插件的扩展</li>
<li><strong>NoScript</strong> 神器，控制网站的js</li>
<li><strong>adblock plus</strong>  去广告</li>
<li><strong>Add to Search Bar</strong> 把一些常用的搜索加到搜索栏，如豆瓣。用它配合<strong>Context Search X</strong>使用</li>
<li><strong>All-in-One Sidebar</strong>    侧边栏管理插件，下载等等</li>
<li><strong>AutoPager</strong> 自动加载下一页</li>
<li><strong>AutoProxy</strong> 科学上网</li>
<li><strong>Context Search X</strong> 右击菜单选择指定搜索引擎来搜索鼠标选中的内容</li>
<li><s><strong>DownThemAll</strong> 下载管理</s></li>
<li><strong>feedly</strong>  rss reader</li>
<li><strong>flashblock</strong> 默认禁止页面的flash，加快加载，页面体验也爽些</li>
<li><s><strong>https finder</strong> 如果网页支持https，会自动用https</s></li>
<li><strong>instasaver</strong> instapaper的插件</li>
<li><strong>lastpass</strong> 密码管理</li>
<li><strong>Lazarus: From Recovery</strong> 恢复Form里面的输入</li>
<li><strong>memroy fox</strong> 优化firefox的内存</li>
<li><strong>quickdrag</strong> 鼠标拖拽</li>
<li><strong>refcontrol</strong> 修改refer，破防盗链</li>
<li><strong>RSS Handler for Feedly</strong> 在RSS处理项加入Feedly</li>
<li><strong>stumbleupon</strong> 发现好网站、消磨时间必备神器</li>
<li><strong>tab mix plus</strong> 标签管理</li>
<li><strong>UnMHT</strong> 平常是disabled的，有时候用来把网页保存为mht格式</li>
<li><strong>View Source Chart</strong> 更有层次地看网站的源码</li>
<li><s><strong>weibo_wc</strong>  重新定制新浪微博的样式，很整洁舒服</s></li>
<li><strong>wiktionary and google translate</strong> 翻译</li>
<li><strong>wiznote web clipper</strong> 为知插件</li>
</ul>
<p>###greasemonkey插件</p>
<ul>
<li><strong>新浪微博V5 还我漂漂版</strong> 取代weibo_wc</li>
<li><strong>HTTP-to-HTTPS redirector</strong> 本来是用插件版的<strong>http everywhere</strong>和<strong>https finder</strong>的，但可惜前者不能在firefox sync同步，后者发现有时候转不了</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>主页设成空白页，这样每次打开都是自己主动获取信息，而不会在“自己以为有用的网站“上浪费时间和精力</li>
<li>autoproxy+<a href="https://code.google.com/p/greatagent" title="greatagent" target="_blank" rel="external">greatagent</a>，配合https，科学上网</li>
</ul>
<p>###更新 2014.07.03</p>
<p>firefox29更新界面之后，地址栏默认就不能去掉，虽然可以用<strong>classic theme restorer</strong>来回复以前的界面。现在没用vimperator，改用它的分支<strong>Pentadactyl</strong>。它更新比vimperator要频繁，它默认就能把地址栏去掉。</p>
<p>vimperator的一个成员在<a href="http://superuser.com/questions/261174/whats-the-difference-between-vimperator-and-pentadactyl" target="_blank" rel="external">网上</a>回答vimperator和Pentadactyl的区别:</p>
<ul>
<li><p>vimperator致力于让用户更简单地用vim的操作使用firefox</p>
</li>
<li><p>Pentadactyl则更倾向于高级用户，有更强大的定制性</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久好久没有更新blog了，markdown怎么用都忘了。。写blog总结还是很有用的。今天写一下答应过某人写自己firefox的状况。&lt;/p&gt;
&lt;p&gt;###使用感受&lt;/p&gt;
&lt;p&gt;主流的浏览器都用过，坚持用firefox的原因主要是因为&lt;a href=&quot;http://www.vimperator.org&quot; title=&quot;vimperator&quot;&gt;vimperator&lt;/a&gt;，纯键盘地上网很cool很快捷，而且我用的时候会把地址栏、add-on bar等等都去掉，最大化可视范围。&lt;br&gt;虽然现在firefox在内存、响应速度上还是比不上chrome，但谁叫chrome的vim化插件不好用呢～&lt;/p&gt;
&lt;p&gt;另外用firefox写web的时候也比较方便，现在自带的“Responsive Design View”很方便地调试移动端的web体验。firefox每次升级都会有针对developer的new feature，足以看出它很重视开发者的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="http://www.goorockey.com/categories/others/"/>
    
    
      <category term="firefox" scheme="http://www.goorockey.com/tags/firefox/"/>
    
  </entry>
  
  <entry>
    <title>抓网页保存为pdf</title>
    <link href="http://www.goorockey.com/2012/10/29/grap-html-to-pdf/"/>
    <id>http://www.goorockey.com/2012/10/29/grap-html-to-pdf/</id>
    <published>2012-10-28T16:00:00.000Z</published>
    <updated>2021-08-09T15:53:17.699Z</updated>
    
    <content type="html"><![CDATA[<p>最近在刷题，总想把题目保存下来，这样没网的时候也可以做题，放手机里也可以随时做了。所以就想着把题目抓下来保存为比较通用的pdf了。</p>
<p>一开始想的是先做类似整站下载，把文字和图片都抓下来，然后再做html转pdf。自己写工具抓下来的话，要抓图片、修改网页里面图片的链接，昨天调研了一下，没找到用python有什么方便的办法，就放弃这条路了。</p>
<p>今天突然找到，网上还是有很多直接网页保存为pdf的工具、网站的。最方便、强大的要数<a href="http://pdfmyrul" title="pdfmyurl" target="_blank" rel="external">pdfmyurl</a>了。</p>
<a id="more"></a>
<h2 id="pdfmyurl"><a href="#pdfmyurl" class="headerlink" title="pdfmyurl"></a>pdfmyurl</h2><p>可以通过<a href="http://pdfmyurl.com?url=\" target="_blank" rel="external">http://pdfmyurl.com?url=\</a><siteurl\> ,来把指定链接的网页保存为pdf，而且是直接返回的，即用wget <a href="http://pdfmyurl.com?url=\" target="_blank" rel="external">http://pdfmyurl.com?url=\</a><siteurl\>就可以直接得到所需的pdf，不用再按什么按钮之类的了。</siteurl\></siteurl\></p>
<p>在官网上可以发现，pdfmyurl可以算是个api服务，可以通过传很多get参数来得到需要的pdf结果。比较常用的有：</p>
<ul>
<li>--filename    输出的pdf文件名</li>
<li>--page-size   页面大小，默认是A4</li>
<li>--proxy       通过制定的代理访问该页面，–username –password还指定用户和密码</li>
<li>-b            使得到的pdf有目录、书签、页眉等书的样式，不过目录不咋地</li>
</ul>
<p>pdfmyurl已经很强大了，但每次只能完成一个网面的pdf，所以还得想办法做pdf的合并。</p>
<h2 id="pdftk"><a href="#pdftk" class="headerlink" title="pdftk"></a>pdftk</h2><p><a href="http://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/" title="pdftk" target="_blank" rel="external">pdftk</a>也是一个pdf方面的神奇，可以完成pdf合并、合并多个pdf指定页、分割、加水印等，而且是跨windows、linux、mac多个平台的。不过我也只用来合并pdf:</p>
<pre><code>$ pdftk 1.pdf 2.pdf cat output 12.pdf
</code></pre><p>但弄出来的pdf是没有目录的。</p>
<p>所以更好的办法其实是用更强大的latex。不过latex还有待系统地研究，现在的再写个bash就已经满足我90%的要求了～</p>
<hr>
<p>更新：</p>
<ol>
<li><p>今天还是发现了一个用python抓oj的，有空参考一下，自己实现一个。</p>
</li>
<li><p>今天还发现，pdfmyurl似乎对单个ip一定时间内的请求做了限制，超过限制后，请求都会返回一个错误信息的pdf。我就借cjb的tor解决了这个问题（又用tor干了邪恶的事了）。</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在刷题，总想把题目保存下来，这样没网的时候也可以做题，放手机里也可以随时做了。所以就想着把题目抓下来保存为比较通用的pdf了。&lt;/p&gt;
&lt;p&gt;一开始想的是先做类似整站下载，把文字和图片都抓下来，然后再做html转pdf。自己写工具抓下来的话，要抓图片、修改网页里面图片的链接，昨天调研了一下，没找到用python有什么方便的办法，就放弃这条路了。&lt;/p&gt;
&lt;p&gt;今天突然找到，网上还是有很多直接网页保存为pdf的工具、网站的。最方便、强大的要数&lt;a href=&quot;http://pdfmyrul&quot; title=&quot;pdfmyurl&quot;&gt;pdfmyurl&lt;/a&gt;了。&lt;/p&gt;
    
    </summary>
    
      <category term="others" scheme="http://www.goorockey.com/categories/others/"/>
    
    
      <category term="others" scheme="http://www.goorockey.com/tags/others/"/>
    
      <category term="pdf" scheme="http://www.goorockey.com/tags/pdf/"/>
    
  </entry>
  
  <entry>
    <title>玩一下hadoop</title>
    <link href="http://www.goorockey.com/2012/10/21/try-hadoop/"/>
    <id>http://www.goorockey.com/2012/10/21/try-hadoop/</id>
    <published>2012-10-21T15:47:00.000Z</published>
    <updated>2021-08-09T15:53:17.705Z</updated>
    
    <content type="html"><![CDATA[<p>由于某种原因，今天玩了一下<a href="http://hadoop.apache.org/" title="Hadoop" target="_blank" rel="external">Hadoop</a>。正确来说，我是玩<a href="http://code.google.com/p/hop/" title="HOP" target="_blank" rel="external">HOP</a>，一个Hadoop的修改版本。</p>
<blockquote>
<p>The Hadoop Online Prototype (HOP) is a modified version of Hadoop MapReduce that allows data to be pipelined between tasks and between jobs. This can enable better cluster utilization and increased parallelism, and allows new functionality: online aggregation (approximate answers as a job runs), and stream processing (MapReduce jobs that run continuously, processing new data as it arrives). </p>
</blockquote>
<p>就是多了pipeline（流水线）的Hadoop。分布式流水线可以有效加快各jobs在各节点的同步运算。</p>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>我是在linux上弄的，windows下用cygwin也行。</p>
<p>下载HOP压缩包后，看里面的docs就够了，同时src/example还有一些例子。</p>
<p>确保ssh,sshd,rsync,jdk都有了。同时要保证ssh localhost不要输入密码的认证步骤。具体docs/quickstart也有说，可以这样：</p>
<pre><code>$ ssh-keygen -t dsa -P &apos;&apos; -f ~/.ssh/id_dsa
$ cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys
</code></pre><p>然后是设置jdk的目录，修改conf/hadoop-env.sh中JAVA_HOME。一般为/usr/lib/jvm/下的某个java目录，我就直接写成/usr/lib/jvm/default-java了。</p>
<p>这时候执行bin/hadoop就会出现帮助信息了。</p>
<h2 id="跑例程"><a href="#跑例程" class="headerlink" title="跑例程"></a>跑例程</h2><p>Hadoop的文件系统叫<a href="http://hadoop.apache.org/docs/stable/hdfs_design.html" title="HDFS" target="_blank" rel="external">HDFS</a>（Hadoop distribution filesystem)，是一个分布式文件系统。每份数据都会在多个节点有备份，以容错、修复。所有数据都要先放进HDFS才能Hadoop处理。</p>
<p>Hadoop的分布式体系中，有一个NameNode，是master的角色，负责主控各节点，有多个DataNode，是slave，负责真正存储数据。这些可以在conf/master和conf/slave设置。<br>同时还有一个JobTracker，负责调度jobs，默认就是NameNode这个主机一起充当NameNode，这个在conf/hadoop-site.xml设置。另外所有DataNode都是TaskTracker，负责执行jobs。具体更多对conf/hadoop-site.xml的配置参看docs/cluster_setup.html</p>
<p>执行bin/hadoop namenode -format，会创造一个namenode。文件都已某种格式放在/tmp/hadoop-“hostname”那里。</p>
<p>执行bin/start-all.sh会启动hadoop，默认通过<a href="http://localhost:50070/可以访问NameNode，http://localhost:50030/可以访问JobTracker。" target="_blank" rel="external">http://localhost:50070/可以访问NameNode，http://localhost:50030/可以访问JobTracker。</a></p>
<p>现在执行一个例子:</p>
<pre><code>$ mkdir input
$ cp conf/*.xml input/

$ bin/hadoop fs -put intput input   # 把当前文件系统input目录复制为HDFS的input
$ bin/hadoop jar hadoop-*-examples.jar grep input output &apos;dfs[a-z.]+&apos;  # 执行所有example.jar，后面的是参数

# 一段时间后，执行完毕 #
$ bin/hadoop fs -get output output # 把HDFS中的output目录复制为当前文件系统的ouput
$ cat output/* # 打印结果

# 或者直接对HDFS操作 #
$ bin/hadoop fs -ls output
$ bin/hadoop fs -cat output/*
</code></pre><h2 id="WordCount例子"><a href="#WordCount例子" class="headerlink" title="WordCount例子"></a>WordCount例子</h2><p><a href="http://hadoop.apache.org/docs/stable/mapred_tutorial.html" title="WordCount" target="_blank" rel="external">WordCount</a>是hadoop中的另一个例子</p>
<p>Hadoop是通过<a href="http://wiki.apache.org/hadoop/HadoopMapReduce" title="MapReduce" target="_blank" rel="external">MapReduce</a>机制来处理大数据的。Map阶段分割输入的数据，并整合成\<key,value\>的对应关系。每对\<key,value\>对送到Combiner做每个key的整合，当整合出一定数量的\<key,value\>后，\<key,value\>会送到Reducer做处理输出最终的\<key,value\>。</key,value\></key,value\></key,value\></key,value\></key,value\></p>
<pre><code>(input) &lt;k1, v1&gt; -&gt; map -&gt; &lt;k2, v2&gt; -&gt; combine -&gt; &lt;k2, v2&gt; -&gt; reduce -&gt; &lt;k3, v3&gt; (output) 
</code></pre><p>按照<a href="http://hadoop.apache.org/docs/stable/mapred_tutorial.html" title="WordCount" target="_blank" rel="external">WordCount</a>中的代码编辑WordCount.java，然后编译打包生成wordcount.jar:</p>
<pre><code>$ mkdir wordcount_classes
$ javac -classpath hadoop-hop-0.2-core.jar -d wordcount_classes WordCount.java
$ jar -cvf wordcount.jar -C wordcount_classes/ . 
</code></pre><p>然后自行构造一些要统计的文件，放在input目录下。这时候注意，在执行了上一次例子后，如果想把输入文件还是放在HDFS的input下，要先清空原来的文件:</p>
<pre><code>$ bin/hadoop fs -rmr input/
$ bin/hadoop fs -rmr output/

$ bin/hadoop fs -put input input # 把输入文件目录input重新放到HDFS中
$ bin/hadoop jar wordcount.jar org.myorg.WordCount input output  # 执行wordcount.jar

# 执行一段时间后完毕 #

$ bin/hadoop fs -cat output/*  # 打印结果
</code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>尝试了一下Hadoop，还有更多有待研究</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于某种原因，今天玩了一下&lt;a href=&quot;http://hadoop.apache.org/&quot; title=&quot;Hadoop&quot;&gt;Hadoop&lt;/a&gt;。正确来说，我是玩&lt;a href=&quot;http://code.google.com/p/hop/&quot; title=&quot;HOP&quot;&gt;HOP&lt;/a&gt;，一个Hadoop的修改版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Hadoop Online Prototype (HOP) is a modified version of Hadoop MapReduce that allows data to be pipelined between tasks and between jobs. This can enable better cluster utilization and increased parallelism, and allows new functionality: online aggregation (approximate answers as a job runs), and stream processing (MapReduce jobs that run continuously, processing new data as it arrives). &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就是多了pipeline（流水线）的Hadoop。分布式流水线可以有效加快各jobs在各节点的同步运算。&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.goorockey.com/categories/hadoop/"/>
    
    
      <category term="programming" scheme="http://www.goorockey.com/tags/programming/"/>
    
      <category term="hadoop" scheme="http://www.goorockey.com/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>关于exploit exercise nebula level01</title>
    <link href="http://www.goorockey.com/2012/10/10/about-exploit-exercise-nebula-level01/"/>
    <id>http://www.goorockey.com/2012/10/10/about-exploit-exercise-nebula-level01/</id>
    <published>2012-10-09T16:00:00.000Z</published>
    <updated>2021-08-09T15:53:17.697Z</updated>
    
    <content type="html"><![CDATA[<p>今天做<a href="http://exploit-exercises.com/" target="_blank" rel="external">exploit exercise</a>的nebula <a href="http://exploit-exercises.com/nebula/level01" target="_blank" rel="external">level01</a>，长见识了，记录一下。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目提供了/home/flag01/下flag01的源码：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv, char **envp)
{
    gid_t gid;
    uid_t uid;
    gid = getegid();
    uid = geteuid();

    setresgid(gid, gid, gid);
    setresuid(uid, uid, uid);

    system(&quot;/usr/bin/env echo and now what?&quot;);
}
</code></pre><p>flag01的权限：</p>
<p>-rwsr-x— 1 flag01 level01 7322 2011-11-20 21:22 flag01</p>
<p>flag01的uid是用户flag01,gid是level01,suid位被使能了</p>
<a id="more"></a>
<p><strong>解决方法</strong>网上都有：</p>
<pre><code>$ export PATH=/tmp:$PATH    # 把/tmp加到环境变量PATH的最前头
$ cat &quot;/bin/bash&quot; &gt;&gt; /tmp/echo # 在/tmp创建一个echo文件，里面是执行bash
$ chmod +x /tmp/echo # 把/tmp/echo设为执行文件
$ /home/flag01/flag01 # 执行/home/flag01下的flag01

# 顺利以用户flag01起bash
$ getflag # 通关
</code></pre><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>主要原理网上的解法都说得很明白，就是通过env使得执行的echo是我们创建的假echo，成功以用户flag01的权限起bash</p>
<p>我想记录的主要是前面关于uid,gid的操作。</p>
<p><strong>为什么system之前会有getegid,setresgid这些操作呢？没有会怎样？这还会成功吗？</strong></p>
<p>答案是不行的！在<a href="http://stackoverflow.com/questions/8304396/what-is-vulnerable-about-this-c-code" target="_blank" rel="external">stackoverflow</a>找到解答:</p>
<blockquote>
<p>Note that the setting of real user ID, effective user ID and saved set-user-ID by a call to setresuid() before the call to system() in the vulnerable code posted in the question allows one to exploit the vulnerability even when only effective user ID is set to a privileged user ID and real user ID remains unprivileged (as is for example the case when relying on set-user-ID bit on a file as above). Without the call to setresuid() the shell run by system() would reset the effective user ID back to the real user ID making the exploit ineffective. However, in the case when the vulnerable code is run with real user ID of a privileged user, system() call alone is enough.</p>
<p>man page of sh:</p>
<p>If the shell is started with the effective user (group) id not equal to the real user (group) id, and the -p option is not supplied, no startup files are read, shell functions are not inherited from the environment, the SHELLOPTS variable, if it appears in the environment, is ignored, and the effective user id is set to the real user id. If the -p option is supplied at invocation, the startup behavior is the same, but the effective user id is not reset.</p>
</blockquote>
<h2 id="real-user-ID-effective-user-ID，saved-set-user-ID-set-user-ID-bit"><a href="#real-user-ID-effective-user-ID，saved-set-user-ID-set-user-ID-bit" class="headerlink" title="real user ID, effective user ID，saved set-user-ID, set-user-ID bit"></a>real user ID, effective user ID，saved set-user-ID, set-user-ID bit</h2><p>首先明确什么是real user ID, effective user ID，saved set-user-ID, set-user-ID bit</p>
<ul>
<li>real user ID 就是起进程的用户ID。</li>
<li>effective user ID是进程的有效用户ID，决定这个进程对文件系统操作的权限。如果它是root，那这个进程的操作就是以root的权限了。</li>
<li>set-user-id bit是程序的一个特征位，默认不使能，可以通过chmod +s 设置。当set-user-id被使能时，此程序叫SUID程序，程序启动时进程的effective user ID就是这个程序的uid；当set-user-id没被使能，则effective user ID是执行者real user ID。</li>
<li>saved set-user-ID保存着进程启动时effective user ID的值。</li>
</ul>
<p>因为进程内可以通过setuid等来设置effective user ID，也就改变了进程对文件系统操作的权限。但这不是可以随便设为任意的id的。</p>
<ul>
<li>如果进程有管理员权限，则setuid可以把effective user ID设为任意id.</li>
<li>如果进程没有管理员权限，则setuid只能把effective user ID设为real user ID或者saved set-user-id。</li>
</ul>
<p>这就知道saved set-user-ID有什么用了。它就是当程序是SUID程序时，effective user ID可以被设为real user ID和程序启动时的effective user ID，saved set-user-ID就是用来保存这个程序启动时effective user ID的值的，使得setuid可以把effective user ID可以从real user ID设回来。</p>
<h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>然后就是起bash时，如果effective user ID跟real user ID不同，且real user ID不是管理员权限用户，则会把effective user ID设回real user ID。</p>
<p>而我们这样如果没有setresgid,setresuid的话，real user ID是level01, effective user ID是flag01, 起bash时，effective user ID会被设回real user ID，那还只是以level01起bash，而不是flag01起bash了。</p>
<h2 id="system-的安全问题"><a href="#system-的安全问题" class="headerlink" title="system()的安全问题"></a>system()的安全问题</h2><p>在这里也可以看到system()是有安全问题的，因为system()里面是fork完就直接调用execl，使得继承了父进程的effective user ID的子进程执行新的程序。</p>
<p>APUE也说了:</p>
<blockquote>
<p>If it is running with special permissions–eithere set-user-ID or set-group-ID–and wants to spawn another process, a process should use fork() and exec() directly, being certain to change back to normal permissions after the fork(), before calling exec(). The system() function should never be used from a set-user-ID or a set-groupd-ID program.</p>
</blockquote>
<p>意思在SUID程序中，不应该用system()，而是自己写fork()和exec()来实现，并在fork和exec中间，自己处理好id权限问题。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>之前看APUE，用户id这里看得一头雾水，通过这个exercise，总算有点感觉了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天做&lt;a href=&quot;http://exploit-exercises.com/&quot;&gt;exploit exercise&lt;/a&gt;的nebula &lt;a href=&quot;http://exploit-exercises.com/nebula/level01&quot;&gt;level01&lt;/a&gt;，长见识了，记录一下。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;题目提供了/home/flag01/下flag01的源码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

int main(int argc, char **argv, char **envp)
{
    gid_t gid;
    uid_t uid;
    gid = getegid();
    uid = geteuid();

    setresgid(gid, gid, gid);
    setresuid(uid, uid, uid);

    system(&amp;quot;/usr/bin/env echo and now what?&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;flag01的权限：&lt;/p&gt;
&lt;p&gt;-rwsr-x— 1 flag01 level01 7322 2011-11-20 21:22 flag01&lt;/p&gt;
&lt;p&gt;flag01的uid是用户flag01,gid是level01,suid位被使能了&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.goorockey.com/categories/linux/"/>
    
    
      <category term="programming" scheme="http://www.goorockey.com/tags/programming/"/>
    
      <category term="linux" scheme="http://www.goorockey.com/tags/linux/"/>
    
      <category term="security" scheme="http://www.goorockey.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>python发邮件脚本</title>
    <link href="http://www.goorockey.com/2012/09/30/python-send-mail/"/>
    <id>http://www.goorockey.com/2012/09/30/python-send-mail/</id>
    <published>2012-09-29T16:00:00.000Z</published>
    <updated>2021-08-09T15:53:17.703Z</updated>
    
    <content type="html"><![CDATA[<p>项目组有每天值日搞卫生和发工作日报的规定，由于不提醒容易忘记，则想到通过内部邮件定时提醒，练练手。</p>
<p>整个“任务”可以分为发邮件+定时两部分。</p>
<p>##发邮件##</p>
<p>由于服务器是windows系统，google得知，windows下有<a href="http://www.blat.net" target="_blank" rel="external">blat</a>这发邮件的大杀器，所以刚开始是想用blat+批处理做的。</p>
<p>执行<code>blat -h</code>或者看官网上的帮助，使用blat发邮件还是很简单的（所以官网特别提醒不要用blat来发SPAM。。)</p>
<pre><code>blat &lt;邮件正文文件&gt; -from &lt;发送地址&gt; -to &lt;接受地址&gt; -subject &lt;邮件标题&gt; 
        -server &lt;smtp服务器地址&gt; -username &lt;登录服务器用户名&gt; -password &lt;密码&gt;

blat - -body &lt;邮件正文&gt; -from &lt;发送地址&gt; -to &lt;接受地址&gt; -subject &lt;邮件标题&gt; 
        -server &lt;smtp服务器地址&gt; -username &lt;登录服务器用户名&gt; -password &lt;密码&gt;
</code></pre><p>blat还可以通过-install把参数保存到注册表。blat确实是自动发邮件的大杀器！</p>
<p>P.S 在linux实现自动发邮件，可以用msmtp,sendmail等～</p>
<p>这本来是很简单的，但因为任务要根据星期几发送邮件给指定的人，而且我们是12个人分成两周，所以想到用一个二维数组存放成员来实现，这也没什么问题。</p>
<p>问题在于在计算要提醒的人时，要根据今天离开始值日的天数，来从数组获取成员，而这求天数在windows用批处理可不好搞，因为要考虑每月不同天数和闰年啊。</p>
<p>当然也不是不能完成，网上也有方法:</p>
<ul>
<li><a href="http://bbs.bathome.net/thread-11128-1-1.html" target="_blank" rel="external">http://bbs.bathome.net/thread-11128-1-1.html</a></li>
<li><a href="http://bbs.bathome.net/viewthread.php?tid=5659&amp;highlight=%2Bbatman" target="_blank" rel="external">http://bbs.bathome.net/viewthread.php?tid=5659&amp;highlight=%2Bbatman</a></li>
<li><a href="http://bbs.bathome.net/viewthread.php?tid=5682&amp;highlight=%2Bbatman" target="_blank" rel="external">http://bbs.bathome.net/viewthread.php?tid=5682&amp;highlight=%2Bbatman</a></li>
</ul>
<p>嫌麻烦，我还是决定找有现成库的方法来做，所以就想到用有各种库的python实现了。</p>
<a id="more"></a>
<p>python有<a href="http://docs.python.org/library/smtplib.html" title="smtplib" target="_blank" rel="external">smtplib</a>库实现smtp发邮件，核心代码也很简单：</p>
<pre><code>import smtplib
# some code ...
smtp = smtplib.SMTP()
smtp.connect(server)
smtp.login(username, password)
smtp.sendmail(sender, receiver, msg)
smtp.quit()
</code></pre><p>而用python计算相差的天数更是简单不过：</p>
<pre><code>import datetime
# some code ...
days = (datetime.datetime.now() - datetime.datetime(2012,9,30)).days
</code></pre><p>##定时##</p>
<p>定时在windows可以用计划任务实现</p>
<p>P.S 在linux可以用cron实现</p>
<p>##整个代码##</p>
<pre><code>#coding=utf-8
import smtplib
import datetime
import sys

from email.mime.text import MIMEText
from email.header import Header


member = ((&apos;member1&apos;, &apos;member2&apos;, &apos;member3&apos;, &apos;member4&apos;, &apos;member5&apos;, &apos;member6&apos;),
        (&apos;member7&apos;, &apos;member8&apos;, &apos;member9&apos;, &apos;member10&apos;, &apos;member11&apos;, &apos;member12&apos;))

suffix = &apos;@abc.com&apos;

def send_mail(receiver, content_filename,
            sender = &apos;admin@abc.com&apos;,
            server = &apos;192.168.1.1&apos;,
            username = &apos;admin@abc.com&apos;,
            password = &apos;admin&apos;):

    subject = &apos;&apos;
    content = &apos;&apos;

    # 从文件读取邮件正文
    try:
        content_file = open(content_filename, &apos;r&apos;)
        try:
            subject = content_file.readline()
            content = content_file.read()

            # 转为utf-8
            subject = subject.decode(&apos;gbk&apos;, &apos;ignore&apos;).encode(&apos;utf-8&apos;)
            content = content.decode(&apos;gbk&apos;, &apos;ignore&apos;).encode(&apos;utf-8&apos;)
        finally:
            content_file.close()
    except IOError, e:
        sys.stderr.write(&quot;cannot open file &quot; + content_filename)
        return

    content = content + &quot;\n\n系统生成，请勿回复 :)&quot;
    #print content

    # 构造邮件
    msg = MIMEText(content, &apos;plain&apos;, &apos;utf-8&apos;)
    msg[&apos;Subject&apos;] = Header(subject, &apos;utf-8&apos;)
    msg[&apos;From&apos;] = sender
    msg[&apos;To&apos;] = receiver


    if (len(msg) &gt; 0):
        try:
            # stmp模块发送邮件
            smtp = smtplib.SMTP()
            smtp.connect(server)
            smtp.login(username, password)
            smtp.sendmail(sender, receiver, msg.as_string())
            smtp.quit()

            print &quot;Success&quot;
            return True

        except Exception, e:
            print str(e)
            return False


def get_on_duty():
    receiver = &apos;&apos;
    days = (datetime.datetime.now() - datetime.datetime(2012,10,8)).days

    if days &gt; 0:
        days = days + 1 # 提前一天提醒
        week = (days / 7) % 2
        date = (days % 7)

        # 周六发周一的值日
        if date == 6:
            date = 0

        if week &lt; len(member) and date &lt; len(member[week]) and len(member[week][date]) &gt; 1:
            receiver = member[week][date] + suffix

    return receiver


if __name__ == &apos;__main__&apos;:

    if len(sys.argv) &gt; 1:
        job = sys.argv[1]

        # 值日
        if job == &apos;duty&apos;:
            receiver = get_on_duty()
            print receiver

            content_filename = &apos;duty.txt&apos;
            if datetime.datetime.now().weekday() == 5:
                content_filename = &apos;duty_Sat.txt&apos;

            if len(receiver) &gt; len(suffix):
                send_mail(receiver = receiver, content_filename = content_filename)

        # 每天日报提醒
        elif job == &apos;daily&apos;:
            send_mail(receiver = &apos;partner&apos;, content_filename = &apos;daily_alert.txt&apos;)
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目组有每天值日搞卫生和发工作日报的规定，由于不提醒容易忘记，则想到通过内部邮件定时提醒，练练手。&lt;/p&gt;
&lt;p&gt;整个“任务”可以分为发邮件+定时两部分。&lt;/p&gt;
&lt;p&gt;##发邮件##&lt;/p&gt;
&lt;p&gt;由于服务器是windows系统，google得知，windows下有&lt;a href=&quot;http://www.blat.net&quot;&gt;blat&lt;/a&gt;这发邮件的大杀器，所以刚开始是想用blat+批处理做的。&lt;/p&gt;
&lt;p&gt;执行&lt;code&gt;blat -h&lt;/code&gt;或者看官网上的帮助，使用blat发邮件还是很简单的（所以官网特别提醒不要用blat来发SPAM。。)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;blat &amp;lt;邮件正文文件&amp;gt; -from &amp;lt;发送地址&amp;gt; -to &amp;lt;接受地址&amp;gt; -subject &amp;lt;邮件标题&amp;gt; 
        -server &amp;lt;smtp服务器地址&amp;gt; -username &amp;lt;登录服务器用户名&amp;gt; -password &amp;lt;密码&amp;gt;

blat - -body &amp;lt;邮件正文&amp;gt; -from &amp;lt;发送地址&amp;gt; -to &amp;lt;接受地址&amp;gt; -subject &amp;lt;邮件标题&amp;gt; 
        -server &amp;lt;smtp服务器地址&amp;gt; -username &amp;lt;登录服务器用户名&amp;gt; -password &amp;lt;密码&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;blat还可以通过-install把参数保存到注册表。blat确实是自动发邮件的大杀器！&lt;/p&gt;
&lt;p&gt;P.S 在linux实现自动发邮件，可以用msmtp,sendmail等～&lt;/p&gt;
&lt;p&gt;这本来是很简单的，但因为任务要根据星期几发送邮件给指定的人，而且我们是12个人分成两周，所以想到用一个二维数组存放成员来实现，这也没什么问题。&lt;/p&gt;
&lt;p&gt;问题在于在计算要提醒的人时，要根据今天离开始值日的天数，来从数组获取成员，而这求天数在windows用批处理可不好搞，因为要考虑每月不同天数和闰年啊。&lt;/p&gt;
&lt;p&gt;当然也不是不能完成，网上也有方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://bbs.bathome.net/thread-11128-1-1.html&quot;&gt;http://bbs.bathome.net/thread-11128-1-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bbs.bathome.net/viewthread.php?tid=5659&amp;amp;highlight=%2Bbatman&quot;&gt;http://bbs.bathome.net/viewthread.php?tid=5659&amp;amp;highlight=%2Bbatman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bbs.bathome.net/viewthread.php?tid=5682&amp;amp;highlight=%2Bbatman&quot;&gt;http://bbs.bathome.net/viewthread.php?tid=5682&amp;amp;highlight=%2Bbatman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;嫌麻烦，我还是决定找有现成库的方法来做，所以就想到用有各种库的python实现了。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://www.goorockey.com/categories/python/"/>
    
    
      <category term="python" scheme="http://www.goorockey.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Scheme里面的pair和list</title>
    <link href="http://www.goorockey.com/2012/09/25/pair-and-list-in-scheme/"/>
    <id>http://www.goorockey.com/2012/09/25/pair-and-list-in-scheme/</id>
    <published>2012-09-24T16:00:00.000Z</published>
    <updated>2021-08-09T15:53:17.702Z</updated>
    
    <content type="html"><![CDATA[<p>最近学scheme，总结一下pair和list的区别，主要是两点：</p>
<p>1.list一定是pair，但只有以null（空list）结尾的pair才是list</p>
<p>对于(define list1 (list a b c)),list1表现为(a b c),其实也可以写成(a . (b . ()))。</p>
<p>可以看到list其实就是pair,而且是以null结尾的pair。</p>
<p>对于像(a.(b.(c.d)))这样的连续pair，因为没有以空list结尾，所以不是list</p>
<p>所以有：</p>
<pre><code>&gt; (define x &apos;(1 2))
&gt; x
(1 2)
&gt; (list? x)
#t
&gt; (cons? x)
#t
&gt; (cddr x) ; 以null结尾
()

&gt; (define y (cons 1 2))
&gt; (list? y)
#f
&gt; (cons? y)
#f
&gt; (set-cdr! y &apos;()) ; 把y的cdr设为null，使y变成list
&gt; y
(1)
&gt; (list? y) ; 变成了list
#t
&gt; (cons? y)
#t
</code></pre><p>2.pair的显示规则</p>
<p>引用<a href="http://download.plt-scheme.org/doc/html/guide/Pairs__Lists__and_Scheme_Syntax.html" target="_blank" rel="external">这里</a>的解释：</p>
<blockquote>
<p>In general, the rule for printing a pair is as follows: use the dot notation always, but if the dot is immediately followed by an open parenthesis, then remove the dot, the open parenthesis, and the    matching close parenthesis. Thus, (0 . (1 . 2)) becomes (0 1 . 2), and (1 . (2 . (3 . ()))) becomes (1 2 3).</p>
</blockquote>
<p>大意就是，如果pair的“点”紧接着小括号，则这个点和小括号都可以去掉。</p>
<p>所以(a.(b.c))等价于(a b.c), (a.(b.(c.())))等价于(a b c)。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近学scheme，总结一下pair和list的区别，主要是两点：&lt;/p&gt;
&lt;p&gt;1.list一定是pair，但只有以null（空list）结尾的pair才是list&lt;/p&gt;
&lt;p&gt;对于(define list1 (list a b c)),list1表现为(a b c),
    
    </summary>
    
      <category term="lisp" scheme="http://www.goorockey.com/categories/lisp/"/>
    
    
      <category term="lisp" scheme="http://www.goorockey.com/tags/lisp/"/>
    
      <category term="scheme" scheme="http://www.goorockey.com/tags/scheme/"/>
    
  </entry>
  
</feed>
